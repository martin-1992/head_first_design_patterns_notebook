# head first 设计模式笔记


### 策略模式（Strategy Pattern）
　　会变化的部分抽取出来实现为行为类，通过 new 来调用，不会变化的部分则为超类，由子类继承。
  
- 将会变化的部分抽取出来，声明为（行为）接口类型，比如飞行接口。由子类实现不同的具体行为动作类，比如继承飞行接口实现的不会飞的动作、会飞的动作；
- 不会变化的部分实现为超类中的通用方法，比如有一个超类为鸭子类，通用方法为游泳，对象子类继承超类；
- 鸭子子类根据各自要求调用具体的行为动作类。一种鸭子子类引用不会飞的动作类，另一种鸭子子类引用会飞的动作类。

### 观察者模式（Observer Pattern）
　　当有最新消息时通知对象，JavaBeans、RMI、MVC 中都有用到观察者模式。

- 面向接口编程，定义主题和观察者接口；
- 主题接口，实现该接口，即为主题，可通知观察者，一般包含三个方法，注册、删除、通知观察者；
- 观察者接口，所有观察者必须实现该接口的 update() 方法。因为主题在通知所有观察者时，会调用每个观察者的 update 方法；
- 实现主题接口，实即为主题对象。首先创建一个数组，注册、删除观察者即是在数组中添加或删除观察者对象，通知观察者也是通过数组遍历，调用每个观察者的 update() 方法；
- 实现观察者接口，即为观察者对象，可收到主题推送的信息，通过构造器将主题作为参数传入，然后调用主题方法注册观察者。

### 装饰者模式（Decorator Pattern）
　　用于在原有代码功能上加上新的功能，不需要修改现有代码，动态添加。比如 BufferedInputStream 在 InputStream 基础上提供了缓冲区功能。

- 定义一个超类为抽象组件，所有对象类都继承该类，继承的目的是保证超类和子类都同属于类型，达到类型匹配，方便多个子类进行组合嵌套，定义抽象方法，比如价格；
- 继承超类的组件，为抽象装饰者，比如咖啡类，实现抽象方法，价格为 15；
- 继承超类的具体装饰者，构造器中需传入抽象装饰者，因为都都继承同一类，调用相同的方法，比如摩卡的价格 + 构造器传入的继承超类组件的价格，以此类推，奶泡价格 + 摩卡价格 + 咖啡价格，new Whip(new Mocha(new Caffe))；

## 简单工厂模式（Simple Factory Pattern）
　　所有工厂模式都是用来封装对象的创建。工厂方法模式通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。

- 超类定义一个抽象方法，为创建对象的部分；
- 子类继承超类，实现自己的创建对象，即通过子类来创建对象。

## 抽象工厂模式（Abstract Factory Pattern)

## 单件模式（Singleton Pattern）
　　确保类只有一个实例，常用于管理共享资源（数据库连接池、线程池）、缓存、对话框、处理偏好设置和注册表的对象、日志对象，这类对象只能有一个实例，多个实例会出问题。

- 利用静态变量（比如 uniqueInstance）来记录该类的唯一实例；
- 调用 getInstance() 创建实例，考虑到多线程的情况下，使用双重检查锁来判定实例是否创建，如没则创建实例，并赋值给 uniqueInstance 变量保存。如已创建，这直接放回 uniqueInstance 变量。

## 命令模式（Command Pattern）
　　将对象的方法封装在一个命令对象的接口上，进行调用。命令模式用在队列请求中，队列不需要知道对象是谁，只要调用 execute() 即可。
  
- 创建一个命令接口，包含 execute() 和 undo() 方法；
- 所有命令对象需实现命令接口，将自身方法封装在 execute() 中，比如电灯对象的打开电灯方法封装在 execute() 中，冰箱对象的打开冰箱方法封装在 execute() 中。用户不需要知道对象的方法是怎么运作的，只需要调用 execute() 方法即可；
- 宏命令，是将一组命令对象放在数组中，然后遍历调用 execute() 方法。

## 适配器模式
　　有两个接口对象，通过适配器将一个接口对象转换成另一个期望的接口，本质上是封装不兼容对象的方法，即通过实现期望的接口，传入要被转换的对象，将被转换对象的方法封装一层期望接口的方法，这样通过期望接口的方法调用的是被转换对象的方法。如下，
  
- 有两个接口对象，枚举接口 Enumerattion 和 迭代接口 Iterator；
- Enumerattion 接口有两个方法分别为 hasMoreElements() 和 nextElements()，Iterator 接口有三个方法分别为 hasNext()、next()、remove() 方法；
- 适配器将不兼容的 Enumerattion 接口包装起来，兼容 Iterator 对象；
- 构建一个适配器对象，实现 Iterator 接口，然后传入 Enumerattion 对象；
- 实现 Iterator 接口的方法，hasNext() 里封装调用 Enumerattion 对象的 hasMoreElements() 方法，next() 里封装调用 Enumerattion 对象的 nextElements()，由于 Enumerattion 没有对应的 Iterator 接口的 remove() 方法，则抛出异常；

## 外观模式（Facade Pattern）
　　提供了一个统一的接口，用来访问子系统中的一群接口，它定义了一个高层接口，让子系统更容易使用。
  
- 新建一个类；
- 将需要多个类的调用方法封装在一个类的方法中，比如将多个动作封装在一个动作方法中，进行调用。

## 模板方法模式（Template Method Pattern）
　　模板方法模式在一个方法中定义一个算法的骨架，将一些步骤通过定义抽象方法延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤，即子类决定如何实现模板算法中的某些步骤。以 Java 中的排序方法为例，抽象方法为 compareTo，交由子类实现，如何比较两个对象大小，其余由超类的算法步骤定义好。

- 抽象类定义一个算法，包含多个方法步骤的调用；
- 这些方法步骤中，不会变的部分作为超类中的通用方法，会变的部分作为超类中的抽象方法，交由子类实现；

## 迭代器模式（Iterator Pattern）
　　将集合框架的使用方法使用一个通用接口封装，通过该接口的 hasNext()、next() 和 remove() 方法进行调用。

- 定义迭代器接口，方法有 hasNext()、next() 和 remove()；
- 实现迭代器接口，为具体迭代器，构造器传入集合框架，使用迭代器的方法封装传入集合框架的方法，比如迭代器接口 next() 方法封装数组的下标的使用等。

## 组合模式（Composite Pattern）

### reference：
https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html <br />
https://quanke.gitbooks.io/design-pattern-java/
